<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Action Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('action.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Action Functions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="action_intro"></a>
1. INTRODUCTION</h1>
<p>An action function is the function called when a command is accepted by CLI parser. This section describes how to write action functions and what you can do with them.</p>
<h1><a class="anchor" id="action_name"></a>
2. FUNCTION NAMING</h1>
<p>This function name is automatically generated from the command itself by:</p><ol type="1">
<li>Concatenating all keywords and parameter variable names with '_' between them. This includes variable names of optional parameters.</li>
<li>Converting all '-' to '_'.</li>
<li>Prepending 'cparser_cmd_' to it.</li>
</ol>
<p>For example, the command <code>"save roster &lt;STRING:filename&gt;"</code> expects an action function of <code>"cparser_cmd_save_roster_filename"</code>.</p>
<h1><a class="anchor" id="action_params"></a>
3. FUNCTION PARAMETERS</h1>
<p>The first argument of an action function is <a class="el" href="structcparser__context__t.html" title="A structure passed back in action function. ">cparser_context_t</a> which provides some information about the parser state. (More on this later). Each parameter token type corresponds to the following C data type:</p>
<ul>
<li>STRING -&gt; char *</li>
<li>UINT -&gt; uint32_t</li>
<li>INT -&gt; int32_t</li>
<li>HEX -&gt; uint32_t</li>
<li>FLOAT -&gt; double</li>
<li>MACADDR -&gt; <a class="el" href="structcparser__macaddr__t.html" title="48-bit MAC address. ">cparser_macaddr_t</a></li>
<li>IPV4ADDR -&gt; uint32_t</li>
<li>FILE -&gt; char *</li>
</ul>
<p>All parameter tokens of a command are converted into pointers of their corresponding C argument of the action function in order. For example, we have a command </p><pre>"save roster { &lt;STRING:filename&gt; }"</pre><p> that saves all employee record into a file. If 'filename' is not provided, "default.dat" is used. The function prototype of its corresponding action function is:</p>
<pre>
cparser_result_t 
cparser_cmd_save_roster(cparser_context_t *context, char **filename);
</pre><p>The extra pointer is used to indicate if the parameter is present. For optional parameter that is omitted, the pointer will be NULL. For parameters that exist (mandatory or optional), they will point to valid data. You should check against NULL for each optional parameter in your action functions. In our example, it may look something like this:</p>
<pre>
cparser_result_t 
cparser_cmd_save_roster(cparser_context_t *context, char **filename);
{
    char *fname = "default.dat";
    if (filename) {
        fname = *filename;
    }
    // Save the employee roster using 'fname'
    ...
    return CPARSER_OK;
}
</pre><h1><a class="anchor" id="action_retval"></a>
4. RETURNED VALUES</h1>
<p>Each action function must return a cparser_result_t. If there is no error, return CPARSER_OK. Otherwise, return CPARSER_NOT_OK. The processing of an action function is considered failed if the requested action cannot be fullfilled. This can happen even though CLI Parser does parameter checking because application specific constraints cannot be checked. For example, if user enters 14 for a parameter token &lt;UINT:month&gt; which is supposed to be a valid month from 1 to 12, the action function should reject the command and return an error. (Returning an error does not alter CLI Parser processing in anyways currently. In the future, it will increment a counter.)</p>
<h1><a class="anchor" id="action_submode"></a>
5. ENTERING AND LEAVING SUBMODE</h1>
<p>If submode is used, there must be a command for each submode to enter it. Action function of that command should call <a class="el" href="cparser_8h.html#a3746e810dd60ad6e1ed047de6b49a5b3" title="Enter a submode. ">cparser_submode_enter()</a>. An opaque pointer 'cookie' is provide to allow some context of the submode. For example, going back to our interface submode example, 'cookie' can point to the interface structure. The command prompt can also change to indicate what submode you are in; simply provide a string in 'prompt'.</p>
<p>'cookie' can be retrieved by the 'cookie' field of a <a class="el" href="structcparser__context__t.html" title="A structure passed back in action function. ">cparser_context_t</a> (passed in every action function). The first submode uses index 1. The second (nested) submode uses index 2 and etc.</p>
<p>When user enters a command to exit the submode, call <a class="el" href="cparser_8h.html#a878f6ac2f5c1e67904cfda65bbcbf672" title="Leave a submode. ">cparser_submode_exit()</a>.</p>
<h1><a class="anchor" id="privleged_mode"></a>
6. PRIVILEGED MODE</h1>
<p>Each parser is initialized to be in non-privileged mode. In order to enter privileged mode, one must call <a class="el" href="cparser_8h.html#a9fbd3c9a8035d55b38d2d4805516d86d" title="Set the privileged mode. ">cparser_set_privileged_mode()</a> with enable=1. Usually, privileged mode requires an adminstrator password to enter. <a class="el" href="cparser_8h.html#aa931c34e43503d6dd155f60eefa15327" title="Read a raw string from the user via the terminal. ">cparser_user_input()</a> is provided to receive user input. Line editing is still available during the user input but characters are not echoed back to the terminal.</p>
<p>Please see "show employee &lt;HEX:id&gt; bonus-factor" command in test_parser for a detail example.</p>
<h1><a class="anchor" id="cli_api"></a>
7. OTHER USEFUL API</h1>
<h2><a class="anchor" id="cli_load"></a>
7.1 Loading A Script</h2>
<p><a class="el" href="cparser_8h.html#a61c81022cdbf3a887d62655b83f01888" title="Load a command/config file to the parser. ">cparser_load_cmd()</a> feeds a text file into the parser. It automatically exits submode by examining indentation. Submodes are indented from its parent mode. If a line indentation is less than the previous line, it automatically exits the submode. This behavior is identical to Cisco CLI.</p>
<h2><a class="anchor" id="cli_help"></a>
7.2 Display A Help Summary</h2>
<p><a class="el" href="cparser_8h.html#a6c5aeb783eadee922456e5675f9c8c22" title="Walk the parser tree and generate a list of all available commands. ">cparser_help_cmd()</a> generates a summary of all available commands in the parse tree. The final output is similar to the original .cli file (or files). This function provides a more convenient alternative to creating a separate command that displays all available commands. Since this function walks the compiled parse tree, it will never fail to list an existing command. If a separate help command is created, developer may forget to update the help command when new commands are introduced.</p>
<p>It also have an optional filter string. If 'str' is non-NULL, it is * used to filter out commands. Any command with a keyword that has 'str' as a substring is displayed. All other commands are omitted. This feature is useful when the number of commands in the system is very large and user just want to find a small set of commands (possibly with the same keywords or prefixes).</p>
<h2><a class="anchor" id="cli_walk"></a>
7.3 Walk The Parse Tree</h2>
<p><a class="el" href="cparser_8h.html#a257a60c620c049f7f42637d22eb530cb" title="Walk the parse tree in the parser. ">cparser_walk()</a> walks through the entire parse tree and invokes up to two callbacks for each node. One application of this function is <a class="el" href="cparser_8h.html#a6c5aeb783eadee922456e5675f9c8c22" title="Walk the parser tree and generate a list of all available commands. ">cparser_help_cmd()</a>. Another example of this function application is to save configuration. One can walk through the tree and locate all commands that generate states. Each command can then regenerate CLI commands that will recreate the state.</p>
<h2><a class="anchor" id="cli_quit"></a>
7.4 Quit The Parser</h2>
<p><a class="el" href="cparser_8h.html#af3a2f8cdaca1c5e0384e94af411b60ae" title="Exit a parser session. ">cparser_quit()</a> causes CLI parser to exit from <a class="el" href="cparser_8h.html#a8248d5ba2096e834bf645f509807f389" title="Run the parser. ">cparser_run()</a>.</p>
<h2><a class="anchor" id="cli_user_input"></a>
7.5 User Input</h2>
<p>At times, it is useful if the CLI parser can accept user input. <a class="el" href="cparser_8h.html#aa931c34e43503d6dd155f60eefa15327" title="Read a raw string from the user via the terminal. ">cparser_user_input()</a> is provided to accept user input. Calling this function puts the parser into a user state where an arbitrary string is accepted. The buffer to hold the string is given in this function call. In addition, a callback function must be provided. The function returns immediately without accepting any input. When &lt;ENTER&gt; is input, the callback function is called.</p>
<p>This approach may seem unnecessarily complicated at first sight. However, it may be needed if the parser input does not come from the terminal. For example, imagine the parser input is from a network socket. Then, the process needs to return from <a class="el" href="cparser_8h.html#aa931c34e43503d6dd155f60eefa15327" title="Read a raw string from the user via the terminal. ">cparser_user_input()</a> call in order to receive the user input. With the callback function, the way input is fed into the cparser is identical during normal parsing or during user input. When &lt;ENTER&gt; is received in user input, the line is processed just like a normal command.</p>
<p>One can use this function to accept a password for entering privileged mode. (In that case, <em>echoed</em> should be set to 0.) </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
